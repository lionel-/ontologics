---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)

library(tidyverse)
```
# ontologics <a href='https://github.com/luckinet/ontologics/'><img src='man/figures/logo.svg' align="right" height="200" /></a>

<!-- badges: start -->
[![R-CMD-check](https://github.com/luckinet/ontologics/workflows/R-CMD-check/badge.svg)](https://github.com/luckinet/ontologics/actions)
[![Coverage
Status](https://codecov.io/gh/luckinet/ontologics/branch/master/graph/badge.svg)](https://codecov.io/github/luckinet/ontologics?branch=master)
[![CRAN\_Status\_Badge](http://www.r-pkg.org/badges/version/ontologics)](https://cran.r-project.org/package=ontologics)
[![](http://cranlogs.r-pkg.org/badges/grand-total/ontologics)](https://cran.r-project.org/package=geometr)

<!-- badges: end -->


## Overview

The `ontologics` package provides tools to build and work with an ontology of [linked (open) data](https://en.wikipedia.org/wiki/Linked_data) in a tidy workflow. In the current workflow the data are only available at the three star level in comma-separated values tables, or actually an R-optimised *.rds file of such a table.

The type of ontology is inspired by the [FAO caliper](https://datalab.review.fao.org/datalab/caliper/web/) platform and makes use of the Simple Knowledge Organisation System ([SKOS](https://www.w3.org/TR/skos-reference/)).

The key tasks, beyond creating a formally valid ontology, is *extracting* concepts and their relation to other concepts and *mapping* new concepts to an existing ontology to capture and set potentially deviating definitions into relation.


## Installation

Install the official version from CRAN:

```{r, eval=FALSE}
install.packages("ontologics")
```

Install the latest development version from github:

```{r, eval=FALSE}
devtools::install_github("luckinet/ontologics")
```


## Create an ontology

An ontology is any data structure that stores concept of any knowledge field in a linked way. It is typically built on a set of standardised/harmonised terms that have a clear definition and potentially some attributes. According to the SKOS, concepts can have semantic relations or can be mapped to one another. Semantic relations describe how *harmonised concepts* **relate** to one another and mappings describe which concepts *from different vocabularies* should be **linked** to one another.

```{r}
library(ontologics)

# work in process

# for now, load an internal ontology
cropOntology <- system.file("extdata", "crops.rds", package = "ontologics")
```

## Build an ontology by adding incoming concepts

When an ontology exists already, it can be used either by looking up which concepts exist in it, which relations the concepts have among each other or by adding and linking new concepts to the already existing concepts.

```{r concept matches}
# already existing ontology for some project about crops
(crops <- load_ontology(path = cropOntology))

# new concepts that occur in some dataset, which should be harmonised with the ontology
newConcepts <- c("Wheat", "NUTS", "Avocado")
```

The new concepts are from different conceptual levels, both 'Wheat' and 'Avocado' are the crop itself, while 'NUTS' is an aggregate of various crops (such as walnut, hazelnut, etc). Let's first find out whether these concepts are in fact new concepts because they are missing from the ontology.

```{r get_concepts missing}
(missingConcepts <- get_concept(label_en = newConcepts, missing = TRUE, path = cropOntology))
```
This tells us that that both 'NUTS' and 'Wheat' don't seem to be missing from the ontology. We try to extract these concepts...

```{r get_concept}
get_concept(label_en = newConcepts[1:2], path = cropOntology)
```

... and see that 'Wheat' is a *class* and not a *crop* and 'NUTS' doesn't have any *broader* concept. We should probably check the hierarchical structure of the ontology for these two concepts as well. For 'NUTS' we can ask directly for the respective *code* and for 'Wheat' we would ask for the *broader* code. We see already here that the code has the same length, so 'NUTS' and whatever the parent of 'Wheat' are should be at the same hierarchical level.

```{r get_concept tree}
# note that this time we are not querring 'label_en' but 'code'
get_concept(code = c("_02"), tree = TRUE, path = cropOntology)
get_concept(code = c("_10"), tree = TRUE, path = cropOntology)
```

It seems that 'NUTS' is not missing from the ontology, and has two child concepts. 'Wheat' is also not missing, but is defined as the wrong concept of type *class*, hence the crop 'Wheat' is in fact missing. 'Avocado' is also missing and has to be specified as new harmonised concept together with 'Wheat'.

By studying the ontology (as above), we can identify the semantic relation between the new concepts and the already harmonised concepts, in other words, into which already existing concepts the new harmonised concepts shall be nested. For the new harmonised concepts, we chose the lower capital letter words to show the difference between those and the external concepts.

```{r set_concept}
new_concept(new = c("wheat", "avocado"),
            broader = c("Wheat", "Tropical and subtropical Fruit"),
            class = "crop",                                         
            source = "external_dataset", 
            path = cropOntology)
```

Eventually, all new concepts can be mapped to already harmonised concepts. Even though 'NUTS' already exists, this also applies to this new concept, because the already existing concept 'NUTS' doesn't necessarily have to be the same as the new concept 'NUTS' (*note: yes, this is a deliberate example, to make this exact point ;)*). This all depends on the respective definitions. When setting a new mapping, the type and the certainty of the match have to be defined. For 'wheat' this is a *close* match, because the concepts are very related. for 'NUTS' this is, after checking the theoretical definitions also a *close* match. 'Avocado' is nested into 'Tropical Fruit' and thus has the match type *broad* (because Tropical Fruit is broader than Avocado).

```{r set_mapping}
set_mapping(concept = c("wheat", "NUTS", "avocado"),
            external = newConcepts,
            match = c("close", "close", "broad"), 
            source = "external_dataset",
            certainty = 3, 
            path = cropOntology)
```

Now we can check whether the updated ontology is as we'd expect, for example by looking at the tree of the respective items again. We should expect that the new harmonised concepts now appear in the ontology and that they have some link to an external concept defined.

```{r new ontology}
get_concept(label_en = "Wheat", tree = TRUE, path = cropOntology)
get_concept(label_en = "NUTS", tree = TRUE, path = cropOntology)
get_concept(label_en = "FRUIT", tree = TRUE, path = cropOntology)
```

We can, moreover check whether the external concepts are properly defined

```{r check up}
crops_updated <- read_rds(file = cropOntology)
crops_updated$attributes %>% 
  arrange(source)
```

